#!/usr/bin/env python
import sys
sys.path.append('../.')
sys.path.append('.')

import os
import os.path as path
import getpass
import glob
import optparse
import socket
import shutil
import time
import numpy as np
import h5py
from empryonic import track
from empryonic import io

def write_events(events, fn):
        dis = []
        app = []
        div = []
        mov = []
        print "-- Writing results to " + path.basename(fn)
        for event in events:
            if event.type == track.EventType.Appearance:
                app.append( (event.traxel_ids[0], event.energy) )
            if event.type == track.EventType.Disappearance:
                dis.append( (event.traxel_ids[0], event.energy) )
            if event.type == track.EventType.Division:
                div.append( (event.traxel_ids[0], event.traxel_ids[1],event.traxel_ids[2],event.energy))
            if event.type == track.EventType.Move:
                mov.append( (event.traxel_ids[0],event.traxel_ids[1], event.energy))

        # convert to ndarray for better indexing
        dis = np.asarray(dis)
        app = np.asarray(app)
        div = np.asarray(div)
        mov = np.asarray(mov)

        # write only if file exists
        with io.LineageH5(fn, 'r+') as f_curr:
            tg = f_curr.create_group("tracking")
            
            # write associations
            if len(app):
                ds = tg.create_dataset("Appearances", data=app[:,:-1], dtype=np.int32)
                ds.attrs["Format"] = "cell label appeared in current file"

                ds = tg.create_dataset("Appearances-Energy", data=app[:,-1], dtype=np.double)
                ds.attrs["Format"] = "lower energy -> higher confidence"

            if len(dis):
                ds = tg.create_dataset("Disappearances", data=dis[:,:-1], dtype=np.int32)
                ds.attrs["Format"] = "cell label disappeared in current file"

                ds = tg.create_dataset("Disappearances-Energy", data=dis[:,-1], dtype=np.double)
                ds.attrs["Format"] = "lower energy -> higher confidence"


            if len(mov):
                ds = tg.create_dataset("Moves", data=mov[:,:-1], dtype=np.int32)
                ds.attrs["Format"] = "from (previous file), to (current file)"

                ds = tg.create_dataset("Moves-Energy", data=mov[:,-1], dtype=np.double)
                ds.attrs["Format"] = "lower energy -> higher confidence"

                
            if len(div):
                ds = tg.create_dataset("Splits", data=div[:,:-1], dtype=np.int32)
                ds.attrs["Format"] = "ancestor (previous file), descendant (current file), descendant (current file)"

                ds = tg.create_dataset("Splits-Energy", data=div[:,-1], dtype=np.double)
                ds.attrs["Format"] = "lower energy -> higher confidence"

        print "-> results successfully written"


        
if __name__=="__main__":
    usage = """%prog [options] FILES
Track cells.

Before processing, input files are copied to OUT_DIR. Groups, that will not be modified are not
copied but linked to the original files to improve execution speed and storage requirements.
"""

    parser = optparse.OptionParser(usage=usage)
    parser.add_option('-o', '--output-dir', type='str', dest='out_dir', default='tracked', help='[default: %default]')
    parser.add_option('-a', '--appearance', type='float', dest='app', default=500, help='appearance cost [default: %default]')
    parser.add_option('-d', '--disappearance', type='float', dest='dis', default=500, help='disappearance cost [default: %default]')
    parser.add_option('-e', '--detection', type='float', dest='det', default=10, help='detection weight [default: %default]')
    parser.add_option('-m', '--misdetection', type='float', dest='mis', default=200, help='misdetection weight [default: %default]')
    parser.add_option('-p', '--opportunity_cost', type='float', dest='opp', default=0, help='opportunity cost [default: %default]')
    parser.add_option('--mean_div_dist', type='float', dest='mdd', default=25, help='average division distance [default: %default]')
    parser.add_option('--min_angle', type='float', dest='ma', default=0, help='minimal division angle [default: %default]')
    parser.add_option('--random-forest', type='string', dest='rf_fn', default=None, help='use cellness prediction instead of indicator function for (mis-)detection energy')
    parser.add_option('--with-visbricks', action='store_true', dest='with_visbricks', help='write out a "time dependent HDF5" file for visbricks')
    parser.add_option('--with-rel-linking', action='store_true', dest='with_rel_linking', help='link hdf5 files relative instead of absolute')
    parser.add_option('--full-copy', action='store_true', dest='full_copy', help='do not link to but copy input files completely')
    parser.add_option('--user', type='str', dest='user', default=getpass.getuser(), help='user to log [default: %default]')
    parser.add_option('--date', type='str', dest='date', default=time.ctime(), help='datetime to log [default: %default]')
    parser.add_option('--machine', type='str', dest='machine', default=socket.gethostname(), help='machine to log [default: %default]')
    parser.add_option('--comment', type='str', dest='comment', default='none', help='some comment to log [default: %default]')

    options, args = parser.parse_args()

    numArgs = len(args)
    if numArgs > 0:
        fns = []
        for arg in args:
            fns.extend(glob.glob(arg))
	    fns.sort()
    else:
        parser.print_help()
        sys.exit(1)
        
    if not path.exists( options.out_dir ):
        os.makedirs( options.out_dir )

    ### Copy input data
    print "Copying input data..."
    working_fns = []
    for fn in fns:
        out_fn = path.join(options.out_dir, path.basename(fn))

        # test, if fn is a valid h5 file
        try:
            f_in = io.LineageH5( fn, 'r' )
        except Exception as e:
            print e
            print "!! Not a valid H5 file: " + fn + " -> skipped"
            continue
        f_in.close()
        del f_in

        if options.full_copy:
            print "-- Copy: " + fn + " -> " + out_fn
            shutil.copy(fn, out_fn)
        else:
            print "-- Link/copy: " + fn + " -> " + out_fn
            with io.LineageH5( out_fn, 'w' ) as f_out:
                if options.with_rel_linking:
                    link_to = path.relpath(path.abspath(path.dirname(fn)), start=path.abspath(path.dirname(out_fn)))
                else:
                    link_to = path.abspath(path.dirname(fn))
                link_fn = path.join(link_to, path.basename(fn))
                f_out["features"] = h5py.ExternalLink( link_fn, "features")
                f_out["segmentation"] = h5py.ExternalLink( link_fn, "segmentation")
                f_out["raw"] = h5py.ExternalLink( link_fn, "raw")
                
                with io.LineageH5( fn, 'r' ) as f_in:
                    has_objects = "objects" in f_in.keys()
                if has_objects:
                    f_out["objects"] = h5py.ExternalLink( link_fn, "objects")
            del f_out
        
        #store out-filename for later use
        working_fns.append(out_fn)
    working_fns.sort()
    print

    ### Do the tracking
    start = time.time()

    # read all traxels into TraxelStore
    ts = track.TraxelStore()
    for i,fn in enumerate(working_fns):
        print "-- reading Traxels from " + fn
        f = io.LineageH5(fn, 'r', timestep=i)
        traxels = f.cTraxels()
        ts.add_from_Traxels(traxels)
        f.close()
        del f
        print "-> %d traxels read" % len(traxels)

    print "Start tracking..."
    if(options.rf_fn):
	    tracker = track.MrfTracking(options.rf_fn, options.app, options.dis, options.det, options.mis, True, options.opp,options.mdd,options.ma)
    else:
	    tracker = track.MrfTracking("none", options.app, options.dis, options.det, options.mis, False, options.opp)
    events = tracker(ts)

    print "Length of events " + str(len(events))
    assert(len(events) +1 == len(working_fns))
    for i,events_at in enumerate(events):
        write_events(events_at, working_fns[i+1])
 
    stop = time.time()
    since = stop - start
    print "Elapsed time [s]: " + str(int(since))
    print "Elapsed time [min]: " + str(int(since) / 60)
    print "Elapsed time [h]: " + str(int(since) / 3600)
    

    ### visbricks file
    if options.with_visbricks: 
        io.write_visbricks_file( working_fns, options.out_dir )
        print "Visbricks file written in '" + options.out_dir + "'"
