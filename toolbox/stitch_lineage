#!/usr/bin/env python
from collections import namedtuple
import glob
import h5py
import numpy as np
import os
import os.path as path
import optparse

from empryonic import io

def connect(curr_h5file, next_h5file, prev_label, next_label):
    def highest_label( h5file ):
        return max(h5file.get_ids())
    # inject a mock cell
    mocklabel = 1 + highest_label( curr_h5file )
    print "-- injecting mock cell (label " + str(mocklabel) + ")"
    next_h5file["/features"].copy(str(next_label), curr_h5file["/features"], name=str(mocklabel))
    

    curr_h5file["/features/labelcount"][0] = curr_h5file["/features/labelcount"][0] + 1
    lc = curr_h5file["/features/labelcontent"].value
    lc = np.resize(lc, lc.size + 1)
    lc[-1] = 1
    del curr_h5file["/features/labelcontent"]
    curr_h5file["/features"].create_dataset("labelcontent", data=lc)
    assert(curr_h5file["/features/labelcontent"].value.size == mocklabel)

    curr_h5file.rm_disappearance( prev_label)
    curr_h5file.add_move( prev_label, mocklabel)

    next_h5file.rm_appearance( next_label)
    next_h5file.add_move( mocklabel, next_label)

    print "-> stitched: " + str(prev_label) + " -> " + str(mocklabel) + " ->  "  + str(next_label)



def stitch(prev_fn, curr_fn, next_fn, curr_time, distance_threshold = 100):
    prev_f = io.LineageH5(prev_fn, 'r')
    curr_f = io.LineageH5(curr_fn)
    next_f = io.LineageH5(next_fn)
    n_stitches = 0
    n_still_lost = 0
    total_dist = 0

    print "Start stitching between " + path.basename(curr_fn) + " and " + path.basename(next_fn) + "..."
    if not curr_f.has_tracking():
        print "!! 'tracking' group missing in " + curr_fn + " -> skipped"
        print
        prev_f.close()
        curr_f.close()
        next_f.close()
        return np.asarray((n_stitches, n_still_lost, total_dist))
    if not next_f.has_tracking():
        print "!! 'tracking' group missing in " + next_fn + " -> skipped"
        print
        prev_f.close()
        curr_f.close()
        next_f.close()
        return np.asarray((n_stitches, n_still_lost, total_dist))

    # search for diss
    diss = curr_f.get_disappearances()
    apps = next_f.get_appearances()
    if diss.size > 0 and apps.size > 0:
        print "-- Searching for disappearances..."
        dis_traxels = [ t for t in prev_f.Traxels( curr_time-1 ) if t.id in diss ]
        assert(len(dis_traxels) == diss.size)
        print "-> Found "+ str(len(dis_traxels))  +" disappearances"

        print "-- Searching for appearances..."
        app_traxels = [ t for t in next_f.Traxels( curr_time+1 ) if t.id in apps ]
        assert(len(app_traxels) == apps.size)
        print "-> found "+ str(len(app_traxels))+" appearances"

        print "-- searching suitable stitches..."
        for d in dis_traxels:
            dist, candidate = d.nearest_neighbor( app_traxels )
            if dist <= distance_threshold:
                print "-> " + str(d.id) +" at t" + str(d.t) + " ~~~ " + str(candidate.id) + " at t" + str(candidate.t) + " (distance " + str(dist) + ")"
                connect(curr_f, next_f, d.id, candidate.id)
                app_traxels.remove(candidate)
                if not len(app_traxels) > 0:
                    break
                n_stitches += 1
                total_dist += dist
            else:
                n_still_lost += 1
                print "-> lost without a trace: " + str(d)
            print                    
    else:
        print "-> found no (dis-)appearances"

    print
    print "STATISTICS"
    print
    print "Stitched: " + str(n_stitches)
    print "Still lost: " + str(n_still_lost)
    if n_stitches != 0:
        print "Avg. dist.: " + str(total_dist / n_stitches)
    print
    print
    print
    prev_f.close()
    curr_f.close()
    next_f.close()

    return np.asarray((n_stitches, n_still_lost, total_dist))



if __name__=="__main__":
    # option parser
    usage = """%prog [options] FILES
Connect tracks by inserting mock cells.

Before processing, input files are copied to 'stitched-threshold_THRESHOLD'. Groups, that will not be modified are not
copied but linked to the original files to improve execution speed and storage requirements.
"""

    parser = optparse.OptionParser(usage=usage)
    parser.add_option('-t', '--threshold', type='float', dest='threshold', default=100, help='only tracks below this distance threshold will be stitched [default: %default]')
    parser.add_option('--with-visbricks', action='store_true', dest='with_visbricks', help='write out a "time dependent HDF5" file for visbricks')

    options, args = parser.parse_args()

    numArgs = len(args)
    if numArgs > 0:
        fns = []
        for arg in args:
            fns.extend(glob.glob(arg))
    else:
        parser.print_help()
        sys.exit(1)
        
    out_dir = "stitched-threshold_" + str(options.threshold)
    if not path.exists( out_dir ):
        os.makedirs( out_dir )

    stats = np.asarray((0,0,0))

    ### Copy input data
    print "Copying input data..."
    working_fns = []
    for fn in fns:
        out_fn = path.join(out_dir, path.basename(fn))
        print "-- Link/copy: " + fn + " -> " + out_fn

        # test, if fn is a valid h5 file
        try:
            f_in = io.LineageH5( fn, 'r' )
        except:
            print "!! Not a valid H5 file: " + fn + " -> skipped"
            continue
        f_in.close()
        del f_in

        with io.LineageH5( out_fn, 'w' ) as f_out:
            link_to = path.relpath(path.abspath(path.dirname(fn)), start=path.abspath(path.dirname(out_fn)))
            link_fn = path.join(link_to, path.basename(fn))
            f_out["features"] = h5py.ExternalLink( link_fn, "/features")
            f_out["segmentation"] = h5py.ExternalLink( link_fn, "/segmentation")
            with io.LineageH5( fn, 'r' ) as f_in:
                if 'tracking' in f_in.keys():
                    f_in.copy("tracking", f_out)
        del f_out, f_in
        
        #store out filename for later use
        working_fns.append(out_fn)
    print

    ### visbricks file
    if options.with_visbricks:
        visbricks_fn = path.join(out_dir, "visbricks_time-dependent-h5.txt")
        print "Writing visbricks file: " + visbricks_fn
        # visbricks requires tracking group
        vis_files = []
        for fn in working_fns:
            with io.LineageH5( fn ) as f_h5:
                if "tracking" in f_h5.keys():
                    vis_files.append( fn )
            del f_h5

        with open( visbricks_fn, 'w') as f:
            f.write("0 " + str(len(vis_files)-1) + "\n")
            for fn in vis_files:
                f.write(path.abspath(fn)+"\n")
        print

    ### Do the stitching
    n_fns = len(working_fns)
    for i in xrange(n_fns-2):
        stats += stitch(working_fns[i], working_fns[i + 1], working_fns[i + 2], i+1, options.threshold)

    ### Print some statistics
    n_stitches = stats[0]
    n_still_lost = stats[1]
    total_dist = stats[2]
    print
    print "TOTAL STATISTICS"
    print
    print "Stitched: " + str(n_stitches)
    print "Still lost: " + str(n_still_lost)
    if n_stitches != 0:
        print "Avg. dist.: " + str(total_dist / n_stitches)
    print 
